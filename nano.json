{"title":"Send emails using Nodemailer, Gmail ,Node.js, and Express.js","url":"https://github.com/waldo237","description":"A Node and Express server configured to send emails between different email hosts. It uses the SMTP protocol","screenshot":"https://firebasestorage.googleapis.com/v0/b/waldomilanes1.appspot.com/o/1_ovGD0BgtbRTncM4luzTNlQ.jpeg?alt=media&token=221a82b8-4553-4670-b789-82125224230a","technology":"node","comments":[],"date":"2020-03-27T18:59:03.483Z","rating":[],"code":{"dir":[{"name":"Node Mailer","type":"dir","content":[{"name":"controllers","type":"dir","content":[{"name":"emailController.js","type":"file","content":"const nodemailer = require('nodemailer');\r\nconst isEmail = require('validator/lib/isEmail');\r\nconst escape = require('validator/lib/escape');\r\n\r\nconst messageValidator = (user) => {\r\n  const responseObject = {\r\n    valid: true,\r\n    errors: [],\r\n  };\r\n\r\n  if (!user.name) {\r\n    responseObject.errors.push({ type: 'name', message: 'Please do not forget to include your name.' });\r\n    responseObject.valid = false;\r\n  } else if (user.name.length < 3) {\r\n    responseObject.errors.push({ type: 'name', message: 'The name should be longer than 3 characters.' });\r\n    responseObject.valid = false;\r\n  }\r\n\r\n  if (!user.email) {\r\n    responseObject.errors.push({ type: 'email', message: 'Please do not forget to include your email address.' });\r\n    responseObject.valid = false;\r\n  } else if (!isEmail(user.email)) {\r\n    responseObject.errors.push({ type: 'email', message: 'The email your provided is not correct.' });\r\n    responseObject.valid = false;\r\n  }\r\n\r\n  if (!user.message) {\r\n    responseObject.errors.push({ type: 'message', message: 'Please do not forget to include your message.' });\r\n    responseObject.valid = false;\r\n  } else if (user.message.length < 15) {\r\n    responseObject.errors.push({ type: 'message', message: 'The message should be longer than 15 characters.' });\r\n    responseObject.valid = false;\r\n  }\r\n\r\n  if (responseObject.valid) {\r\n    responseObject.sanitized = {\r\n      name: escape(user.name.trim()),\r\n      email: escape(user.email.trim()),\r\n      message: escape(user.message.trim()),\r\n    };\r\n  }\r\n  return responseObject;\r\n};\r\n\r\nexports.emailController = (req, res) => {\r\n  try {\r\n    if (!messageValidator(req.body).valid) {\r\n      return res.status(400).send({ message: messageValidator(req.body).errors.map((err) => err.message).join(', ') });\r\n    }\r\n\r\n    const mailOptions = {\r\n      from: req.body.email,\r\n      to: process.env.EMAILTO,\r\n      subject: `Message from ${req.body.name}, sent from waldomilanes.com`,\r\n      text: req.body.message,\r\n    };\r\n\r\n    const transporter = nodemailer.createTransport({\r\n      service: 'gmail',\r\n      auth: {\r\n        user: process.env.EMAIL,\r\n        pass: process.env.PASSWORD,\r\n      },\r\n    });\r\n\r\n    return transporter.sendMail(mailOptions, (err) => {\r\n      if (err) {\r\n        return res.status(500).json({ message: 'An Error has occured while sending the email', err });\r\n      }\r\n      return res.status(200).json({ message: 'Your Message was successfully sent' });\r\n    });\r\n  } catch (error) {\r\n    return res.status(500).json({ message: 'Error processing request.' });\r\n  }\r\n};\r\n"},{"name":"userController.js","type":"file","content":"/* eslint-disable no-underscore-dangle */\r\n/* eslint-disable consistent-return */\r\nconst mongoose = require('mongoose');\r\nconst bcrypt = require('bcrypt');\r\nconst jwt = require('jsonwebtoken');\r\nconst nodemailer = require('nodemailer');\r\nconst { UserSchema, TokenSchema } = require('../models/userModel');\r\nconst { verificationEmailInHTML } = require('./verificationEmailInHTML');\r\n\r\nconst User = mongoose.model('User', UserSchema);\r\nconst Token = mongoose.model('Token', TokenSchema);\r\n\r\n/**\r\n * @function login confirm that the user data is valid and send a token if it does.\r\n */\r\nconst login = (req, res) => {\r\n  try {\r\n    User.findOne({ email: req.body.email }, (err, user) => {\r\n      if (err) throw err;\r\n      if (!user) {\r\n        return res.status(401).json({ message: 'Authentication failed. \"You have entered an invalid username or password\"' });\r\n      } if (user && req.body.password) {\r\n        if (!user.comparePassword(req.body.password, user.hashPassword)) {\r\n          return res.status(401).json({ message: 'Authentication failed. \"You have entered an invalid username or password\"' });\r\n        }\r\n        // Make sure the user has been verified\r\n        if (!user.isVerified) {\r\n          return res.status(401).send({\r\n            type: 'not-verified',\r\n            message: 'Your account has not been verified. Please check your inbox or',\r\n            link: { label: 'Send another email', href: `http://${req.headers.host}/auth/resend-vefication-token/false` },\r\n          });\r\n        }\r\n\r\n        return res.status(200).json({\r\n          message: 'You have successfully logged in.',\r\n          token: jwt.sign(\r\n            { hashed_access: bcrypt.hashSync(user.email, 5), email: user.email, _id: user._id },\r\n            process.env.APP_KEY,\r\n          ),\r\n        });\r\n      }\r\n      res.status(401).json({ message: 'Authentication failed. \"You have entered an invalid username or password\"' });\r\n    });\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n};\r\n\r\n/**\r\n * @function directLoginWithProvider() return a JWT\r\n */\r\nconst directLoginWithProvider = (req, res, next, user) => {\r\n  res.status(200).json({\r\n    message: 'You have successfully logged in.',\r\n    token: jwt.sign(\r\n      { hashed_access: bcrypt.hashSync(user.email, 5), email: user.email, _id: user._id },\r\n      process.env.APP_KEY,\r\n    ),\r\n  });\r\n  return next();\r\n};\r\n/**\r\n * @function sendVerificationTokenToEmail Create a verification token for this user,\r\n * save token, Send the email\r\n * @param {*} req\r\n * @param {*} res\r\n * @param {*} user\r\n */\r\nconst sendVerificationTokenToEmail = (req, res, user) => {\r\n  // Create a verification token for this user\r\n  const jsonToken = jwt.sign({\r\n    hashed_access: bcrypt.hashSync(user.email, 5),\r\n    email: user.email,\r\n  }, process.env.APP_KEY);\r\n  // eslint-disable-next-line no-underscore-dangle\r\n  const token = new Token({ _userId: user._id, token: jsonToken });\r\n\r\n  // save token\r\n  token.save((err) => {\r\n    if (err) return res.status(500).send({ message: err.message });\r\n    // Send the email\r\n    const transporter = nodemailer.createTransport({\r\n      service: 'gmail',\r\n      auth: {\r\n        user: process.env.EMAIL,\r\n        pass: process.env.PASSWORD,\r\n      },\r\n    });\r\n    const mailOptions = {\r\n      from: process.env.EMAILFROM,\r\n      to: user.email,\r\n      subject: 'Account Verification Token',\r\n      html: verificationEmailInHTML(req.headers.host, user, token.token),\r\n    };\r\n    return transporter.sendMail(mailOptions, (error) => {\r\n      const serverSideRendered = req.params.ssr === 'true';\r\n      if (error) {\r\n        return (serverSideRendered)\r\n          ? res.status(500).render('index', { successful: false, message: error.message })\r\n          : res.status(500).send({ message: error.message });\r\n      }\r\n      return (serverSideRendered)\r\n        ? res.status(200).render('index', { successful: true, message: `A verification email has been sent to ${user.email}.` })\r\n        : res.status(200).send({ message: `A verification email has been sent to ${user.email}.` });\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * @function loginRequired(), middleware that confirms that req.user exists,\r\n * otherwise sends a response message with 'Unauthorized user!'.\r\n */\r\nexports.loginRequired = (req, res, next) => {\r\n  if (req.user) {\r\n    next();\r\n  } else {\r\n    return res\r\n      .status(401)\r\n      .json({ message: 'Unauthorized user!' });\r\n  }\r\n};\r\n\r\n/**\r\n * @function register\r\n * register user to database if email is unique.\r\n * if hasIdByProvider the email is verified immediately\r\n * and the user is signed in/a new token is sent.\r\n * else send email with token and return a notification message.\r\n */\r\nconst register = async (req, res, next) => {\r\n  try {\r\n    // define boolean if already exists.\r\n    const alreadyExists = await User.findOne({ email: req.body.email }, (err, user) => {\r\n      if (err) throw err;\r\n      if (user) return true;\r\n    });\r\n\r\n    if (alreadyExists) {\r\n      return res.status(401).json({ message: 'Email already taken.' });\r\n    }\r\n    console.log(req.body)\r\n    const newUser = new User(req.body);\r\n    newUser.hashPassword = bcrypt.hashSync(req.body.password, 10);\r\n    // verify user if has a valid id from a provider\r\n    const hasIdByProvider = req.body.cu_id && req.originalUrl === '/auth/withProvider';\r\n    if (hasIdByProvider) newUser.isVerified = true;\r\n    newUser.save((err, user) => {\r\n      if (err) return res.status(500).send({ message: 'There was an issue with your request. Please try again.' });\r\n      if (hasIdByProvider) return directLoginWithProvider(req, res, next, user);\r\n\r\n      return sendVerificationTokenToEmail(req, res, user);\r\n    });\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n};\r\n\r\n/**\r\n * @function registerWithProvider\r\n * search user on database\r\n * use the cu_id as password\r\n * if the user already exist, the email and cu_id will be used to signIn ---> signin function.\r\n * else a new user is created using the credentials sent ---> register route\r\n */\r\nexports.registerWithProvider = async (req, res, next) => {\r\n  try {\r\n    const alreadyExists = await User.findOne({ email: req.body.email }, (err, user) => {\r\n      if (err) throw err;\r\n      if (user) return true;\r\n    });\r\n    req.body.password = await req.body.cu_id;\r\n\r\n    if (alreadyExists) {\r\n      return login(req, res);\r\n    }\r\n    return register(req, res, next);\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n};\r\n\r\n/**\r\n * @function resendTokenPost gets called if user wants to receive a token one more time.\r\n */\r\nexports.resendVerificationToken = async (req, res) => {\r\n  try {\r\n    User.findOne({ email: req.body.email }, (err, user) => {\r\n      if (err) throw err;\r\n      if (!user) return res.status(400).send({ message: 'We were unable to find a user with that email.' });\r\n      if (user.isVerified) {\r\n        return (req.params.ssr)\r\n          ? res.status(400).render('index', { message: 'This account has already been verified. Please log in.' })\r\n          : res.status(400).send({ message: 'This account has already been verified. Please log in.' });\r\n      }\r\n      sendVerificationTokenToEmail(req, res, user);\r\n    });\r\n  } catch (error) {\r\n    console.log(error);\r\n    res.status(500).send('An  error occured while fetching the data');\r\n  }\r\n};\r\n\r\nconst verifyUser = (req, res) => {\r\n  try {\r\n    User.findOne({ _id: req.params.id, email: req.params.email }, (err, user) => {\r\n      if (!user) return res.status(400).render('index', { successful: false, type: 'user-not-found', message: 'We were unable to find a user for this token.' });\r\n      if (user.isVerified) {\r\n        return res.status(200).render('index', {\r\n          successful: true, type: 'already-verified', message: 'This account has already been verified.', link: 'https://waldomilanes.com/followers',\r\n        });\r\n      }\r\n\r\n      // Verify and save the user\r\n      // eslint-disable-next-line no-param-reassign\r\n      user.isVerified = true;\r\n      user.save((error) => {\r\n        if (error) return res.status(500).render('index', { successful: false, message: err.message });\r\n        return res.status(200).render('index', { successful: true, message: 'The account has been verified', link: 'https://waldomilanes.com/followers' });\r\n      });\r\n    });\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n};\r\nconst assertion = (params) => {\r\n  const errors = [];\r\n  // eslint-disable-next-line global-require\r\n  const isEmail = require('validator/lib/isEmail');\r\n  if (!params.email) errors.push('Email cannot be blank');\r\n  if (!params.id) errors.push('id cannot be blank');\r\n  if (!params.token) errors.push('Token cannot be blank');\r\n  if (!isEmail(params.email)) errors.push('Email is not valid');\r\n  return errors;\r\n};\r\n/**\r\n * @returns render with instructions\r\n * @function emailConfirmation Handle  token once user is redirected from their inbox.\r\n */\r\nexports.emailConfirmation = (req, res) => {\r\n  // Check for validation errors\r\n  const errors = assertion(req.params);\r\n  if (errors.length) return res.status(400).render('index', { successful: false, type: 'not-verified', message: errors });\r\n\r\n  // Find a matching token\r\n  Token.findOne({ token: req.params.token }, (err, token) => {\r\n    try {\r\n      if (err) throw err;\r\n      if (!token) {\r\n        return User.findOne({ email: req.params.email }, (error, user) => {\r\n          if (error) throw error;\r\n          if (user) { // check that the user is valid and offer to resend token\r\n            return res.status(401).render('index', {\r\n              successful: false,\r\n              type: 'expired-token',\r\n              resend: true,\r\n              user,\r\n              message: 'We were unable to find a valid token. Your token might have expired.',\r\n            });\r\n          }\r\n          return res.status(401).render('index', {\r\n            successful: false,\r\n            type: 'expired-token',\r\n            message: 'We were unable to find a valid token. Your token might have expired.',\r\n          });\r\n        });\r\n      }\r\n      // If we found a token, find a matching user\r\n      verifyUser(req, res, true);\r\n    } catch (error) {\r\n      return res.status(500).send('There was an issue while processing your request, please verify the data and try again.');\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * @function fetchPayloadFromJWT it receives JWT token, fetches payload and returns it\r\n * @param token a valid  JWT token\r\n */\r\nconst fetchPayloadFromJWT = (token) => JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString());\r\n\r\n/**\r\n * @function userIsLoggedIn\r\n *  it receives JWT token, fetches payload --> hashed_access and email,\r\n *  compares it against hashing algorithm\r\n *  send it back with code401 or code200\r\n */\r\nexports.userIsLoggedIn = (req, res) => {\r\n  try {\r\n    const { token } = req.body;\r\n    const pL = (token) ? fetchPayloadFromJWT(token) : null;\r\n    const comparisonPassed = bcrypt.compareSync(pL.email, pL.hashed_access);\r\n\r\n    if (comparisonPassed) {\r\n      return res.status(200).json(`${pL.hashed_access}code200`);\r\n    }\r\n    return res.status(401).json(`${pL.hashed_access}code401`);\r\n  } catch (error) {\r\n    return res.status(500).send('There was an issue while processing your request, please verify the data and try again.');\r\n  }\r\n};\r\n\r\n// declared exports\r\nexports.login = login;\r\nexports.register = register;\r\nexports.fetchPayloadFromJWT = fetchPayloadFromJWT;\r\n"}]},{"name":"index.js","type":"file","content":"\r\nconst express = require('express');\r\nconst app = express();\r\nconst mongoose = require('mongoose');\r\nconst bodyParser = require('body-parser');\r\nif (process.env.NODE_ENV !== 'production') require('dotenv').config();\r\nconst cors = require('cors');\r\nconst RateLimit = require('express-rate-limit');\r\nconst helmet = require('helmet');\r\nconst morgan = require('morgan');\r\nconst jsonwebtoken = require('jsonwebtoken');\r\nconst { createWriteStream } = require('fs');\r\nconst { join } = require('path');\r\nconst registrationRoutes = require('./src/routes/registrationRoutes');\r\nconst emailRoutes = require('./src/routes/emailRoutes');\r\n\r\nconst PORT = process.env.PORT || 3001;\r\n\r\n// environment variables configuration\r\napp.disable('x-powered-by');\r\n// mongoose connection\r\ntry {\r\n  mongoose.Promise = global.Promise;\r\n  mongoose.connect(process.env.DB_URL, {\r\n    useNewUrlParser: true,\r\n    useUnifiedTopology: true,\r\n    useCreateIndex: true,\r\n  })\r\n    .then(() => console.log(`connected to DataBase successfully! -- ${new Date().toLocaleString()}`))\r\n    .catch((err) => console.log(`Could not connect to DataBase: ${err}`));\r\n} catch (error) {\r\n  console.log(error);\r\n}\r\n\r\n/**\r\n * Middlewares\r\n */\r\n\r\n// throttle if exceeds 300 calls\r\nconst limiter = new RateLimit({\r\n  windowMs: 24 * 60 * 60 * 1000,\r\n  max: 300,\r\n  // delayMs: 0\r\n  message:\r\n    { message: 'You have exceeded the maximum number of interactions from this IP address, please try again after 24 hours.' },\r\n});\r\napp.use(limiter);\r\n\r\n// log only 4xx and 5xx responses to console\r\napp.use(morgan('combined', {\r\n  skip(req, res) { return res.statusCode < 400; },\r\n  stream: createWriteStream(join(__dirname, 'access.log'), { flags: 'a' }),\r\n}));\r\n\r\n// helmet setup\r\napp.use(helmet());\r\n// bodyparser setup\r\n// app.use(bodyParser.urlencoded({ extended: true }));\r\n// app.use(bodyParser.json());\r\napp.use(bodyParser.urlencoded({\r\n  limit: '20mb',\r\n  parameterLimit: 100000,\r\n  extended: true,\r\n}));\r\napp.use(bodyParser.json({\r\n  limit: '20mb',\r\n}));\r\n// cors setup\r\napp.use(cors({ origin: true }));\r\n\r\n\r\n// JWT setup\r\napp.use((req, res, next) => {\r\n  if (req.headers && req.headers.authorization && req.headers.authorization.split(' ')[0] === 'JWT') {\r\n    jsonwebtoken.verify(req.headers.authorization.split(' ')[1], process.env.APP_KEY, (err, decode) => {\r\n      if (err) req.user = undefined;\r\n      req.user = decode;\r\n      next();\r\n    });\r\n  } else {\r\n    req.user = undefined;\r\n    next();\r\n  }\r\n});\r\n\r\n// handle http routes\r\nregistrationRoutes(app);\r\n\r\nemailRoutes(app);\r\n\r\n// handler errors\r\n// eslint-disable-next-line no-unused-vars\r\napp.use((err, req, res, next) => {\r\n  console.error(err.stack);\r\n  res.status(500).send({ message: 'There was an issue with your request. Please try again.' });\r\n});\r\n\r\napp.listen(PORT, () => console.log(`your server is running on port ${PORT} at ${new Date().toLocaleString()}`));\r\n"},{"name":"models","type":"dir","content":[{"name":"userModel.js","type":"file","content":"/* eslint-disable no-useless-escape */\r\nconst mongoose = require('mongoose');\r\nconst bcrypt = require('bcrypt');\r\n\r\nconst { Schema } = mongoose;\r\n\r\nconst ModifiedPasswordSchema = new Schema({\r\n  hasBeendModified: {\r\n    type: Boolean,\r\n  },\r\n  IP: {\r\n    type: String,\r\n  },\r\n  date: {\r\n    type: Date,\r\n    default: Date.now,\r\n  },\r\n});\r\n\r\nexports.UserSchema = new Schema({\r\n  firstName: {\r\n    type: String,\r\n    required: true,\r\n    trim: true,\r\n    minlength: 3,\r\n    maxlength: 60,\r\n  },\r\n  lastName: {\r\n    type: String,\r\n    required: true,\r\n    trim: true,\r\n    minlength: 3,\r\n    maxlength: 60,\r\n  },      \r\n  photoURL: {\r\n    type: String,\r\n    required: false,\r\n    trim: true,\r\n    minlength: 10,\r\n  },\r\n  acccountStatus: {\r\n    type: String,\r\n    validate: /^(active|inactive)$/,\r\n    required: true,\r\n    default: 'active',\r\n  },\r\n  email: {\r\n    type: String,\r\n    required: true,\r\n    trim: true,\r\n    match: /^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$/i,\r\n  },\r\n  hashPassword: {\r\n    type: String,\r\n    required: true,\r\n  },\r\n  isPasswordModified: ModifiedPasswordSchema,\r\n  isVerified: { type: Boolean, default: false },\r\n  created_date: {\r\n    type: Date,\r\n    default: Date.now,\r\n  },\r\n});\r\n\r\n// eslint-disable-next-line max-len\r\nexports.UserSchema.methods.comparePassword = (password, hashPassword) => bcrypt.compareSync(password, hashPassword);\r\nexports.TokenSchema = new Schema({\r\n  token: {\r\n    type: String,\r\n    trim: true,\r\n  },\r\n  userId: {\r\n    type: mongoose.Types.ObjectId,\r\n    trim: true,\r\n  },\r\n  createdAt: {\r\n    type: Date,\r\n    default: Date.now,\r\n    index: { expireAfterSeconds: 600 },\r\n  },\r\n});\r\n"}]},{"name":"package.json","type":"file","content":"{\n  \"name\": \"waldomilanesappbackend\",\n  \"description\": \"API Server for Waldo milanes\",\n  \"scripts\": {\n    \"start\": \"node ./index.js\",\n    \"nodemon\": \"nodemon ./index.js\",\n    \"test\": \"test\",\n    \"heroku\": \"git push heroku  master\",\n    \"serve\": \"firebase serve --only functions\"\n  },\n  \"dependencies\": {\n    \"bcrypt\": \"^5.0.0\",\n    \"body-parser\": \"^1.19.0\",\n    \"cookie-parser\": \"^1.4.5\",\n    \"cors\": \"^2.8.5\",\n    \"express\": \"^4.17.1\",\n    \"express-graphql\": \"^0.12.0\",\n    \"express-rate-limit\": \"^5.1.3\",\n    \"graphql\": \"^15.4.0\",\n    \"helmet\": \"^3.22.0\",\n    \"jsonwebtoken\": \"^8.5.1\",\n    \"lodash\": \"^4.17.20\",\n    \"mongoose\": \"^5.9.10\",\n    \"morgan\": \"^1.10.0\",\n    \"nodemailer\": \"^6.4.10\",\n    \"pug\": \"^3.0.0\",\n    \"validator\": \"^13.1.1\"\n  },\n  \"devDependencies\": {\n    \"dotenv\": \"^8.2.0\",\n    \"eslint-config-airbnb-base\": \"^14.2.0\",\n    \"eslint-plugin-import\": \"^2.22.0\",\n    \"nodemon\": \"^2.0.4\"\n  },\n  \"private\": true,\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/waldo237/waldoMilanesAppBackEnd.git\"\n  },\n  \"keywords\": [\n    \"portfolio\",\n    \"waldo\",\n    \"milanes\",\n    \"w-programming\",\n    \"node\",\n    \"server\",\n    \"express\",\n    \"mongodb\",\n    \"mongoose\"\n  ],\n  \"author\": \"Waldo Milanes\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/waldo237/waldoMilanesAppBackEnd/issues\"\n  },\n  \"homepage\": \"https://github.com/waldo237/waldoMilanesAppBackEnd#readme\"\n}\n"},{"name":"routes","type":"dir","content":[{"name":"emailRoutes.js","type":"file","content":"const rateLimit = require('express-rate-limit');\r\nconst { emailController } = require('../controllers/emailController');\r\n\r\nconst sentEmailsLimiter = rateLimit({\r\n  windowMs: 60 * 60 * 1000, // 1 hour window\r\n  max: 3, // start blocking after 5 requests\r\n  message:\r\n    { message: 'Too many emails sent from this IP, please try again after an hour.' },\r\n});\r\n\r\nconst routes = (app) => {\r\n  app.post('/email', sentEmailsLimiter, emailController);\r\n};\r\n\r\nmodule.exports = routes;\r\n"},{"name":"registrationRoutes.js","type":"file","content":"const rateLimit = require('express-rate-limit');\r\nconst {\r\n  login, register, emailConfirmation, resendVerificationToken, registerWithProvider, userIsLoggedIn,\r\n} = require('../controllers/userController');\r\nconst { sendPasswordResetToken, confirmPasswordResetToken, enterNewPassword } = require('../controllers/passwordResetController');\r\nconst { checkAccountStatus } = require('../controllers/profileController');\r\n\r\nconst accountscreatedLimiter = rateLimit({\r\n  windowMs: 24 * 60 * 60 * 1000, // 1 hour window\r\n  max: 5, // start blocking after 5 requests\r\n  message:\r\n    { message: 'Too many actions of this type from this IP address, please try again after 24 hours.' },\r\n});\r\n\r\nconst routes = (app) => {\r\n  // registration route\r\n  app.route('/auth/register').post(accountscreatedLimiter, register);\r\n  app.route('/auth/withProvider').post(accountscreatedLimiter, registerWithProvider);\r\n  // login route\r\n  app.route('/auth/login').post(checkAccountStatus, login);\r\n  // Token Confirmation\r\n  app.route('/auth/confirmation/:email/:id/:token').get(emailConfirmation);\r\n\r\n  app.route('/auth/resend-vefication-token/:ssr').post(accountscreatedLimiter, resendVerificationToken);\r\n  app.route('/auth/userIsLoggedIn').post(accountscreatedLimiter, userIsLoggedIn);\r\n  app.route('/auth/sendPasswordResetToken').post(accountscreatedLimiter, sendPasswordResetToken);\r\n  app.route('/auth/confirmPasswordResetToken').post(accountscreatedLimiter, confirmPasswordResetToken);\r\n  app.route('/auth/enterNewPassword').post(accountscreatedLimiter, confirmPasswordResetToken, enterNewPassword);\r\n};\r\n\r\nmodule.exports = routes;\r\n"
                            }
                        ]
                    }
                ]
            }
        ]
    }
}